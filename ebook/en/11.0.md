Chapter 11: Longest Common Subsequence 
===========

##1. Introduction
What is the so-called longest common subsequence (LCS)? Given a sequence S, if it's a subsequence of two or more sequence, and also the longest one among all the sequences that meet this condition, then S is the LCS of these sequences.

For example, given two random sequences: 1 3 4 5 5, and 2 4 5 5 7 6, their LCS is: 4 5 5.

There is another confusing concept called 'longest common substring', please pay attention to the difference between 'longest common substring' and 'longest common subsequence': a substring is a continual part of the original sequence, which means every element in a substring has to be adjacent in the original one; but a subsequence just needs to keep the order, the elements do not need to be adjacent. For example, for strings 'acdfg' and 'akdfc', their longest common substring is 'df', and longest common subsequence is 'adf'. The LCS problem can be solved using Dynamic Programming as described below.

##2. Ideas for the Solution
* Brute Force    
  The easiest algorithm comes to us is Brute Force. For every subsequence of sequence X, check if it is the subsequence of sequence Y, therefore identify wheteher it is a common subsequence of X and Y, and record the longest one during this procedure. After all the subsequence of X is examined, we can get the LCS of X and Y. For a sequence X with m elements, denoted by index as {1,2,...,m}, its subsequence can be denoted as a subsequence of {1,2,...,m}. We can infer from this that X has 2^m subsequences, so the complexity for Brute Force is exponential (2^n).

* Dynamic Programming    
We can notice that the LCS problem has the *optimal substructure* attribute.  
For X with m elements and Y with n elements, denote:  
    Xi = <x1,x2,...,xi>, first i elements of sequence X (1≤i≤m)  
    Yj = <y1,y2,...,yj>, first j elements of sequence Y (1≤j≤n)  
Assume Z = <z1,z2,...,zk> ∈ LCS(X, Y).  
    If xm = yn(the last element of X and Y is the same), then it is not difficult to prove that this element must also be the last element of Z, i.e., zk = xm = yn. And obviously, Zk-1∈LCS(Xm-1,Yn-1), so the original problem can reduce to find the LCS(Xm-1,Yn-1), then plus xm; and the length of LCS(X,Y) is length(LCS(Xm-1,Yn-1)) + 1;    
    If xm ≠ yn, we can also prove either Z∈LCS(Xm-1, Y), or Z∈LCS(X, Yn-1). Now the problem reduce to find the LCS(Xm-1, Y) and LCS(X, Yn-1), and pick the longer one. The length of LCS(X,Y) is max{length(LCS(Xm-1,Y)), length(LCS(X,Yn-1))}.

In the situaition when xm ≠ yn, we need to compute the length of LCS(Xm-1, Y) and LCS(X, Yn-1), they both depend on the length of LCS(Xm-1, Yn-1). Furthermore, LCS(X, Y) must contain LCS(Xi, Yj), so this problem has the optimal substructure attribute and therefore we can try Dynamic Programming.

In all, you need 3 things to solve this LCS problem:  
1.LCS(Xm-1, Yn-1)+1;  
2.LCS(Xm-1,Y), LCS(X,Yn-1);  
3.max{length(LCS(Xm-1,Y), length(LCS(X,Yn-1)}. 

I will try to detail the algorithm next.

##3. Dynamic Programming Solution For LCS

###3.1 Stucture of LCS

The structure of LCS can be represented as below:  

    Denote a LCS of sequence X=<x1,x2,...,xm> and Y=<y1,y2,...,yn> as Z=<z1,z2,...,zk>, we have:  
        a. if xm=yn, then zk=xm=yn and Zk-1 is the LCS of Xm-1 and Yn-1;
        b. if xm≠yn and zk≠xm, then Z is the LCS of Xm-1 and Yn;
        c. if xm≠yn and zk≠yn, then Z is the LCS of X and Yn-1;
    Note: Xm-1=<x1,x2,...,xm-1>, Yn-1=<y1,y2,...,yn-1>, Zk-1=<z1,z2,...,zk-1>.

###3.2 Recursive Structure of Subproblem

From the optimal substructure stated last subsection we can know that, to find the LCS of X and Y, we just need to go through the following procedure as below:  
if xm=yn, find the LCS of Xm-1 and Yn-1 and then append xm (or yn);    
if xm≠yn, find the LCS of Xm-1 and Y, and the LCS of X and Yn-1, then pick the longer one.

We can see a *overlapping subproblems* attribute from this recursive structure. For example, when finding the LCS of X and Y, we may need to find the LCS of X and Yn-1 and the LCS of Xn-1 and Y first; and these two both depend on one subproblem, to find the LCS of Xm-1 and Yn-1.

So, let's build the recursive relations among the optimal values of subproblems.   
Denote c[i,j] as the length of Xi and Yj. When i=0 or j=0, the LCS of Xi and Yj is an empty sequence, so c[i,j]=0, otherwise the recursive relation can be defined as below:  
![](../images/11/11.1.jpg)

###3.3 Computing the Optimal Value (length of the lcs)

Using the recursive formula defined last subsection directly, we can easily contrive an algorithm to compute c[i,j], but the time will grow exponentially with the length of input. Since there are only θ(m*n) subproblems in the subporblem space in all, we can use the bottom-up approach to improve the efficiency.

The LCS_LENGTH(X,Y) algorithm takes X=<x1,x2,...,xm> and Y=<y1,y2,...,yn> as inputs and outputs two matrixes c[0..m, 0..n] and b[1..m, 1..n]; c[i,j] stores the length of LCS(Xi, Yj), and b[i,j] denotes how c[i,j] is got (we will explain it later). At the end of the algorithm, the length of LCS(X,Y) will be stored at c[m,n].
```
Procedure LCS_LENGTH(X,Y);  
begin  
  m:=length[X];  
  n:=length[Y];  
  for i:=1 to m do c[i,0]:=0;  
  for j:=1 to n do c[0,j]:=0;  
  for i:=1 to m do  
    for j:=1 to n do  
      if x[i]=y[j] then  
        begin  
          c[i,j]:=c[i-1,j-1]+1;  
          b[i,j]:="↖";  
        end  
      else if c[i-1,j]≥c[i,j-1] then  
        begin  
          c[i,j]:=c[i-1,j];  
          b[i,j]:="↑";  
        end  
      else  
        begin  
          c[i,j]:=c[i,j-1];  
          b[i,j]:="←"  
        end;  
  return(c,b);  
end;   
```

###3.4 Construct The LCS
With the help of matirx b from LCS_LENGTH we can construct the LCS of X and Y. Starting from b[m,n], search the matrix according to the direction of each 'arrow':



    


