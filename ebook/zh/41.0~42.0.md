# 第四十一章~四十二章：荷兰国旗问题、矩阵相乘之Strassen算法

## 前言

本文要讲的两个问题：荷兰国旗和矩阵相乘之Strassen算法都跟分治法相关，故把这两个问题放到了一起。所谓分治，便是分而治之的意思，好比打战时面对敌人庞大的武装部队，采取避其主力，各个击破的策略。

有何问题，欢迎随时不吝指正，thanks。

## 第四十一章、荷兰国旗问题

**题目描述**

现有红白蓝三个不同颜色的小球，乱序排列在一起，请重新排列这些小球，使得红白蓝三色的同颜色的球在一起。这个问题之所以叫荷兰国旗，是因为我们可以将红白蓝三色小球想象成条状物，有序排列后正好组成荷兰国旗。如下图所示：

![img](../images/41~42/41.1.jpg)

**思路分析**

初看此题，我们貌似除了暴力解决并无好的办法，但联想到我们所熟知的快速排序算法呢？我们知道，快速排序时基于分治模式处理的，对一个典型子数组A[p...r]排序的分治过程为三个步骤：

1. 分解：A[p..r]被划分为俩个（可能空）的子数组A[p ..q-1]和A[q+1...r]，使得A[p...q-1] <= A[q] <= A[q+1...r]

2. 解决：通过递归调用快速排序，对子数组A[p...q-1]和A[q+1...r]排序。

3. 合并。
  
 也就是说，快速排序的主要思想便是依托于一个partition分治过程，每一趟排序的过程中，选取的主元都会把整个数组排列成一大一小的序列，继而递归排序完整个数组。

    如下伪代码所示：

快速排序算法的关键是PARTITION过程，它对A[p..r]进行就地重排：

**ARTITION(A, p, r)**
1  x ← A[r]
2  i ← p - 1
3  for j ← p to r - 1
4       do if A[j] ≤ x
5             then i ← i + 1
6                  exchange A[i] <-> A[j]
7  exchange A[i + 1] <-> A[r]
8  return i + 1

![img](../images/41~42/41.2.jpg)

![img](../images/41~42/41.3.jpg)

![img](../images/41~42/42.1.png)

![img](../images/41~42/42.2.png)

![img](../images/41~42/42.3.png)

![img](../images/41~42/42.4.png)

![img](../images/41~42/42.5.png)

![img](../images/41~42/42.6.jpeg)

![img](../images/41~42/42.7.jpeg)

![img](../images/41~42/42.8.jpeg)

![img](../images/41~42/42.9.png)


![equation](http://latex.codecogs.com/gif.latex?a^b)
